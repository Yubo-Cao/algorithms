\documentclass{article}
\usepackage[code, tikz, outputdir=build, math, pl=cpp]{common}

\title{Basic Math}
\author{Yubo \icon{yubo}}
\date{\today}

\begin{document}

\maketitle

\section{Basic Math}

\subsection{Prime}

\paragraph{Trial division}

Prime numbers are natural numbers that are larger than 1 that are only divisible by 1 and themselves.

For example, $2, 3, 5, 7, 11, 13, 17, 19, 23, \cdots$ are prime numbers.

\subsubsection{Determine if a number is prime}

\begin{monos}
bool is_prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i < n; i++)
        if (n % i == 0) return false;
    return true;
}
\end{monos}

The above algorithm has a time complexity of $O(n)$. One might realize that all the factor of a number $n$ appears in pairs, i.e., if $d \mid n$, then $\frac{n}{d} \mid n$. Therefore, we shall only check the smaller number in each pair such that $d \le \frac{n}{d}$ or $d \le \sqrt{n}$.

\begin{monos}
bool is_prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++)
        if (n % i == 0) return false;
    return true;
}
\end{monos}

The above algorithm has a time complexity of $O(\sqrt{n})$ (always). It is advised not to write like \mono!i <= sqrt(n)!. This is because it takes a lot of time to calculate the square root of a number, especially in light that this is executed in a loop. Also, don't write \mono!i * i <= n!. This is because there will have an overflow problem.

\paragraph{Sieve of Eratosthenes}

Maintain a list of all the numbers from 2 to $n$ and mark all the multiples of 2, then 3, then 5, and so on. The numbers that are not marked are prime numbers.

This works, because for all numbers $k$ in the list. If it has not been marked, then it must not be a multiple of any number $j \in [2, k - 1]$. Therefore, it must be a prime number, by definition.

\begin{monos}
void sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n; j += i) st[primes[j] * i] = 1;
    }
}
\end{monos}

The time complexity is

$$
\begin{aligned}
\frac{n}{2} + \frac{n}{3} + \frac{n}{5} + \cdots + \frac{n}{n} &= n (\frac{1}{2} + \frac{1}{3} + \frac{1}{5} + \cdots + \frac{1}{n}) \\
&= n(\ln n + \rm{c}) \\ 
&= O(n \ln n)
\end{aligned}
$$

A quick optimization would be to only mark the prime numbers. Because all the marks that a composite number generates are already marked by the prime numbers that are smaller than it.

\begin{monos}
void sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            for (int j = i; j <= n; j += i) st[j] = 1;
        }
    }
}
\end{monos}



\subsubsection{Prime factorization}

Prime factorization is the process of finding the prime factors of a number. For example, the prime factorization of $12$ is $2 \times 2 \times 3$. This would require trial division.

\begin{monos}
vector<int> prime_factorizaton(int x) {
    vector<int> factors;
    for (int i = 2; i <= x; i++) {
        if (x % i == 0) {
            int s = 0;
            do {
                x /= i;
                s++;
            } while (x % i == 0);
            while (s--) factors.push_back(i);
        }
    }
    return factors;
}
\end{monos}

The above algorithm has a time complexity of $O(n)$. In the above algorithm, we didn't check if $i$ is a prime number. Let's assume $i$ is a composite number and $x \mid i$. As any composite number is composed of prime number factors that are smaller than itself, $p_1, p_2, \cdots, p_k$, then $x \mid p_1, x \mid p_2, \cdots, x \mid p_k$. By our algorithm, any factor that's smaller than $i$ must already be found, thus, a contradiction. Hence, $i$ must be a prime number if $x \mid i$.

\begin{monos}   
vector<int> prime_factorizaton(int x) {
    vector<int> factors;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            int s = 0;
            do {
                x /= i;
                s++;
            } while (x % i == 0);
            while (s--) factors.push_back(i);
        }
    }
    if (x > 1) factors.push_back(x);
    return factors;
}
\end{monos}

The above algorithm has a time complexity of $O(\sqrt{n})$ (worst case). The best case is $O(\log n)$. This works, because $n$ contains at most 1 prime factor that's larger than $\sqrt{n}$. Therefore, when we reached $i > \sqrt{n}$, we can safely assume that $n$ is a prime number.



\end{document}