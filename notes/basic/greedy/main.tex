\documentclass{article}
\usepackage[code]{common}
\usepackage{algorithm2e}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\title{Greedy Algorithm}
\date{\today}
\author{Yubo C., Anish G.}

\begin{document}
\maketitle

\section{Introduction}

Greedy algorithms don't have a template or a pre-defined procedure to follow.
The code is written on the fly and is usually concise, whereas the correctness of the algorithm is harder to prove.
Hence, we shall focus on the problems directly, and provide exhaustive proof of correctness.

\section{Problems}

\subsection{Select Points on an Interval}

Gien $N$ closed intervals $[a_i,b_i]$, please select as few points as possible on the number line, so that each interval contains at least one selected point.

\subsubsection{Solution}

\begin{algorithm}[H]
    \Input{Number of intervals $N$, $N$ intervals $[a_i,b_i]$}
    \Output{Number of selected points $cnt$}
    \BlankLine
    Sort intervals by right endpoint\;
    $cnt \gets 0$\;
    \For{$i \gets 1$ to $N$}
    {
        \If{$[a_i,b_i]$ contains a point}
        {
            pass\;
        }
        \Else
        {
            $cnt \gets cnt + 1$\;
            Select $b_i$ as the selected point\;
        }
    }
    \Return $cnt$\;
\end{algorithm}

\subsubsection{Proof}

We prove that the algorithm will yield a valid solution, first.

\begin{itemize}
    \item If we have only one interval, the algorithm will select the endpoint of the interval.
    \item Assume that the algorithm is correct for $N-1$ intervals. Then, we have the following cases:
          \begin{itemize}
              \item If the $N$th interval contains a point, then the algorithm will pass.
              \item Otherwise, the algorithm will select the right endpoint of the $N$th interval.
          \end{itemize}
          In both cases, the algorithm is correct.
    \item Hence, the algorithm is correct for $N$ intervals.
\end{itemize}

Therefore, $ans \le cnt$.

Now we want to prove that this will converge to the optimal solution.

\begin{itemize}
    \item If we have only one interval, the answer is $1$, which is the same as the algorithm's output.
    \item Assuming that the algorithm is correct for $N-1$ intervals. Then, we have the following cases:
          \begin{itemize}
              \item If the $N$th interval contains the point, the algorithm will simply pass over it, and the result will be the same as for the first $N-1$ intervals, which is already proven to be correct.
              \item Otherwise, the algorithm will select the $b_N$ as the point. This solution is optimal, as, if any point, $p > a_N$, to the left of $b_N$ is selected and this still constitutes a valid solution, then there must be an overlap of all the intervals covered by $b_N$ from $(p, b_N)$. But considering the interval that started in $(p, B_p)$, then it would not be covered by $p$ and would need another point, which is a contradiction. Hence, $b_N$ is the optimal solution.
          \end{itemize}
\end{itemize}

Therefore, $ans \ge cnt$. And therefore, $ans = cnt$.

\subsubsection{Implementation}

\begin{minted}{java}
    int n = Integer.parseInt(br.readLine());
    int[][] intervals = new int[n][2];
    for (int i = 0; i < n; i++) {
        String[] line = br.readLine().split(" ");
        intervals[i][0] = Integer.parseInt(line[0]);
        intervals[i][1] = Integer.parseInt(line[1]);
    }
    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
    long count = 0, end = Long.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        if (intervals[i][0] > end) {
            count++;
            end = intervals[i][1];
        }
    }
    System.out.println(count);
\end{minted}


\end{document}