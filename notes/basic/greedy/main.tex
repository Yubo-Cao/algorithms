\documentclass{article}
\usepackage[code]{common}

\usepackage{algorithm2e}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\usepackage{fontspec}
\setmonofont[Ligatures=TeX, Contextuals=Alternate]{Fira Code Retina}

\title{Greedy Algorithm}
\date{\today}
\author{Yubo~C., Anish~G.}

\begin{document}
\maketitle

\newpage

\section{Introduction}

Greedy algorithms don't have a template or a pre-defined procedure to follow.
The code is written on the fly and is usually concise, whereas the correctness of the algorithm is harder to prove.
Hence, we shall focus on the problems directly, and provide exhaustive proof of correctness.

\section{Interval}

\subsection{Select Points on an Interval}

Gien $N$ closed intervals $[a_i,b_i]$, please select as few points as possible on the number line, so that each interval contains at least one selected point.

\subsubsection{Solution}

\begin{algorithm}[H]
    \Input{Number of intervals $N$, $N$ intervals $[a_i,b_i]$}
    \Output{Number of selected points $cnt$}
    \BlankLine
    Sort intervals by right endpoint\;
    $cnt \gets 0$\;
    \For{$i \gets 1$ to $N$}
    {
        \If{$[a_i,b_i]$ contains a point}
        {
            pass\;
        }
        \Else
        {
            $cnt \gets cnt + 1$\;
            Select $b_i$ as the selected point\;
        }
    }
    \Return $cnt$\;
\end{algorithm}

\subsubsection{Proof}

We prove that the algorithm will yield a valid solution, first.

\begin{itemize}
    \item If we have only one interval, the algorithm will select the endpoint of the interval.
    \item Assume that the algorithm is correct for $N-1$ intervals. Then, we have the following cases:
    \begin{itemize}
        \item If the $N$th interval contains a point, then the algorithm will pass.
        \item Otherwise, the algorithm will select the right endpoint of the $N$th interval.
    \end{itemize}
    In both cases, the algorithm is correct.
    \item Hence, the algorithm is correct for $N$ intervals.
\end{itemize}

Therefore, $ans \le cnt$.

Now we want to prove that this will converge to the optimal solution.

\begin{itemize}
    \item If we have only one interval, the answer is $1$, which is the same as the algorithm's output.
    \item Assuming that the algorithm is correct for $N-1$ intervals. Then, we have the following cases:
    \begin{itemize}
        \item If the $N$th interval contains the point, the algorithm will simply pass over it, and the result will be the same as for the first $N-1$ intervals, which is already proven to be correct.
        \item Otherwise, the algorithm will select the $b_N$ as the point. This solution is optimal, as, if any point, $p > a_N$, to the left of $b_N$ is selected and this still constitutes a valid solution, then there must be an overlap of all the intervals covered by $b_N$ from $(p, b_N)$. But considering the interval that started in $(p, B_p)$, then it would not be covered by $p$ and would need another point, which is a contradiction. Hence, $b_N$ is the optimal solution.
    \end{itemize}
\end{itemize}

Therefore, $ans \ge cnt$. And therefore, $ans = cnt$.

\subsubsection{Implementation}

\begin{minted}{java}
    int n = Integer.parseInt(br.readLine());
    int[][] intervals = new int[n][2];
    for (int i = 0; i < n; i++) {
        String[] line = br.readLine().split(" ");
        intervals[i][0] = Integer.parseInt(line[0]);
        intervals[i][1] = Integer.parseInt(line[1]);
    }
    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
    long count = 0, end = Long.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        if (intervals[i][0] > end) {
            count++;
            end = intervals[i][1];
        }
    }
    System.out.println(count);
\end{minted}

\subsection{Maximum non-overlapping segments}

Given $N$ closed intervals $[a_i,b_i]$, please select as many intervals as possible on the number line, so that each interval does not overlap with any other selected interval.

\subsubsection{Proof}

Interestingly, the solution for this problem is the same as the previous one. However, the proof is slightly different.

First, we prove that this algorithm yields a valid solution.

\begin{itemize}
    \item If we have only one interval, the algorithm will select the interval.
    \item Assuming this algorithm is correct for $N-1$ intervals, we have the following cases:

    \begin{itemize}
        \item If the $N$th interval overlaps with previous selected point $p$, then we will pass over it.
        \item Otherwise, we will set $p = b_N$ and select the $N$th interval. We also increment the counter.
    \end{itemize}

    The algorithm's newly selected interval will not overlap with the previously selected interval, by all means.
\end{itemize}

Therefore, $ans \ge cnt$.

Now, we want to prove that you can't select any more intervals. Assume we can find a solution with $cnt + 1$ intervals. Then we should be able to find another interval that does not overlap with any of the selected intervals. By proof in the previous question, all the intervals must contain at least 1 point. Therefore, there doesn't exist any interval that does not overlap with any of the selected intervals. By contradiction, we have proven that the algorithm is correct.

\subsection{Grouping Interval}

Given $N$ closed intervals $[a_i,b_i]$, please group these intervals into as few groups as possible, so that each group has no overlapping intervals, and the number of groups is as small as possible.

\subsubsection{Solution}

\begin{algorithm}[H]
    \Input{Number of intervals $N$, $N$ intervals $[a_i,b_i]$}
    \Output{Number of groups $cnt$}
    \BlankLine
    Sort intervals by left endpoint\;
    $cnt \gets 0$\;
    \For{$i \gets 1$ to $N$}
    {
        \If{$[a_i,b_i]$ can be put into an existing group(s)}
        {
            Put $[a_i,b_i]$ into the group (any one)\;
        }
        \Else
        {
            $cnt \gets cnt + 1$\;
            Create a new group\;
            Put $[a_i,b_i]$ into the group\;
        }
    }
    \Return $cnt$\;
\end{algorithm}

\subsubsection{Proof}

It's easy to see that the algorithm will yield a valid solution, \ie, $ans \le cnt$. However, we want to prove that this algorithm will yield the optimal solution.

\begin{itemize}
    \item If we have only one interval, the algorithm returns $1$, just as the optimal solution.
    \item Assuming that the algorithm is correct for $N-1$ intervals, we have the following cases:
    \begin{itemize}
        \item We can put the $N$th interval into an existing group. Then the result will be the same as for the first $N-1$ intervals, which is already optimal.
        \item Otherwise, we will create a new group and put the $N$th interval into it. This is necessary, as we can see all the existing groups must have at least one interval that has its right endpoints on the new interval (as they wouldn't have overlapped otherwise), and their left endpoint must all be smaller than or equal to the left end points of the new interval (as we sorted them). Hence, all those groups, and the last interval, must have overlapped here. Therefore, it's impossible to create $cnt - 1$ groups while still keeping them separated, as by the pigeonhole principle.
    \end{itemize}
\end{itemize}



\end{document}